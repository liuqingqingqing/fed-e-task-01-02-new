# fed-e-task-01-02-new
简答题
一、10
这是因为用来计数的变量i泄露为全局变量
二、undefined 
这是因为内层变量会覆盖外层变量，if 块内有 var 声明的变量 temp，只是还没有赋值，默认为 undefined。
三、
var arr = [12, 34, 32, 89, 4];
var newArray = Array.from(arr);
var minNum = Math.min(...newArray);
console.log(minNum);
四、
var 定义变量，没有块的概念，可以跨块访问，不能跨函数访问;
let 主要声明块级作用域下的成员，这个成员变量的作用域范围只能在当前块级作用域下；
const 声明变量的同时必须要赋值。声明之后，不允许去修改它的值，即不允许重新指向一个新
的内存地址，可以去修改内存地址中的属性成员。
五、
20
六、
Symbol 值能作为对象属性的标识符
七、
浅拷贝：拷贝对象中的数据，但不拷贝对象中的子对象
深拷贝：会克隆出一个对象，数据相同，但是引用地址不同
八、
TypeScript是JavaScript的超集，有类型约束，更加面向对象
九、
优点：错误更早暴露，代码智能，编码准备，重构更加牢靠，减少不必要的类型判断
缺点：需要耗费人力
十、
原理：通过内部引用计数器来维护当前对象的引用数，判断当前对象的引用数是否为0，如果为0，gc就立即回收
优点：发现垃圾时立即回收，最大程度减少程序暂停
缺点：对于对象之间互有引用的情况，即使对象本身没有被使用，但是引用存在就导致了引用计数不为0，无法被回收的情况
十一、
递归的寻找对象之间的引用获取所有可达对象，并为其做上标记，将未被标记的对象移动，使其在地址上连续，然后回收相应的空间
十二、
新生代对象采用复制算法+标记整理进行回收,新生代内存区会被分成两块相同大小的From和To，活动的对象存储在From空间内，当From空间应用到一定大小的时候就会触发GC操作，使用标记整理并整理活动对象的地址，使其连续，然后将活动对象拷贝至To，然后From空间进行内存释放。当一轮GC执行完毕之后还存活的新生代则需要晋升。当To空间的使用率超过25%的时候，同样需要将此次的活动对象均移动到老生代中。当完成一次GC操作之后，From和To需要进行置换。
十三、
在老生代变量进行回收的时候也会采用增量标记算法进行效率优化。让其不会一口气的去寻找到所有活动对象。而是会穿插在程序的运行中执行，降低了程序的卡顿，当标记彻底采集完毕之后，才会把程序停下来，进行垃圾回收。